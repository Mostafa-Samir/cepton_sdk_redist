/*
  Copyright Cepton Technologies Inc. 2017, All rights reserved.

  Cepton Sensor SDK C interface.
*/
#ifndef CEPTON_SDK_H
#define CEPTON_SDK_H

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#include "cepton_sdk_def.h"

// Required for MATLAB
#ifndef CEPTON_EXPORT
#define CEPTON_EXPORT
#endif
#ifndef CEPTON_DEPRECATED
#define CEPTON_DEPRECATED
#endif

/// API version
#define CEPTON_SDK_VERSION 19

/// Returns library version.
/**
 * This is different from `CEPTON_SDK_VERSION`.
 */
CEPTON_EXPORT const char *cepton_sdk_get_version_string();
CEPTON_EXPORT int cepton_sdk_get_version_major();
CEPTON_EXPORT int cepton_sdk_get_version_minor();

//------------------------------------------------------------------------------
// Errors
//------------------------------------------------------------------------------

enum _CeptonSensorErrorCode {
  CEPTON_SUCCESS = 0,
  CEPTON_ERROR_GENERIC = -1,
  CEPTON_ERROR_OUT_OF_MEMORY = -2,
  CEPTON_ERROR_SENSOR_NOT_FOUND = -4,
  CEPTON_ERROR_SDK_VERSION_MISMATCH = -5,
  CEPTON_ERROR_COMMUNICATION = -6,  ///< Networking error
  CEPTON_ERROR_TOO_MANY_CALLBACKS = -7,
  /// Invalid value or uninitialized struct
  CEPTON_ERROR_INVALID_ARGUMENTS = -8,
  CEPTON_ERROR_ALREADY_INITIALIZED = -9,
  CEPTON_ERROR_NOT_INITIALIZED = -10,
  CEPTON_ERROR_INVALID_FILE_TYPE = -11,
  CEPTON_ERROR_FILE_IO = -12,
  CEPTON_ERROR_CORRUPT_FILE = -13,
  CEPTON_ERROR_NOT_OPEN = -14,
  CEPTON_ERROR_EOF = -15,

  CEPTON_FAULT_INTERNAL = -1000,  ///< Internal parameter out of range
  CEPTON_FAULT_EXTREME_TEMPERATURE = -1001,  ///< Reading exceed spec
  CEPTON_FAULT_EXTREME_HUMIDITY = -1002,     ///< Reading exceeds spec
  CEPTON_FAULT_EXTREME_ACCELERATION = -1003,
  CEPTON_FAULT_ABNORMAL_FOV = -1004,
  CEPTON_FAULT_ABNORMAL_FRAME_RATE = -1005,
  CEPTON_FAULT_MOTOR_MALFUNCTION = -1006,
  CEPTON_FAULT_LASER_MALFUNCTION = -1007,
  CEPTON_FAULT_DETECTOR_MALFUNCTION = -1008,
};
typedef int32_t CeptonSensorErrorCode;

/// Returns string name of error code.
/**
 * Returns empty string if error code is invalid.
 */
CEPTON_EXPORT const char *cepton_get_error_code_name(
    CeptonSensorErrorCode error_code);
/// Returns true if error name is of the form `CEPTON_ERROR_*`, false otherwise.
CEPTON_EXPORT int cepton_is_error_code(CeptonSensorErrorCode error_code);
/// Returns true if error name is of the form `CEPTON_FAULT_*`, false otherwise.
CEPTON_EXPORT int cepton_is_fault_code(CeptonSensorErrorCode error_code);

/// Returns and clears last sdk error.
/**
 * `error_msg` is owned by the SDK, and is valid until the next call in the
 * current thread.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_get_error(const char **error_msg);

//------------------------------------------------------------------------------
// Types
//------------------------------------------------------------------------------
/// Sensor identifier.
typedef uint64_t CeptonSensorHandle;
static const CeptonSensorHandle CEPTON_NULL_HANDLE = 0LL;
/// Indicates that handle was generated by capture replay.
static const CeptonSensorHandle CEPTON_SENSOR_HANDLE_FLAG_MOCK = 0x100000000LL;

enum _CeptonSensorModel {
  HR80T = 1,
  HR80M = 2,
  HR80W = 3,
  SORA_200 = 4,
  VISTA_860 = 5,  // Deprecated, will be removed in next SDK release.
  HR80T_R2 = 6,
  VISTA_860_GEN2 = 7,
  FUSION_790 = 8,
  VISTA_M90 = 9,
  VISTA_X120 = 10,
  SORA_P60 = 11,
  VISTA_P60 = 12,
  VISTA_X15 = 13,
  VISTA_P90 = 14,
  VISTA_H120 = 15,
  CEPTON_SENSOR_MODEL_MAX = 15,
};
typedef uint16_t CeptonSensorModel;

struct CEPTON_EXPORT CeptonSensorInformation {
  CeptonSensorHandle handle;
  uint64_t serial_number;
  char model_name[28];
  CeptonSensorModel model;
  uint16_t reserved;
  char firmware_version[28];

#ifdef CEPTON_SIMPLE
  uint32_t formal_firmware_version;
#else
  struct {
    uint8_t major;
    uint8_t minor;
    uint8_t unused[2];
  } formal_firmware_version;
#endif

  float last_reported_temperature;  ///< [celsius]
  float last_reported_humidity;     ///< [%]
  float last_reported_age;          ///< [hours]

  float measurement_period;  ///< Time between measurements [seconds].

  int64_t ptp_ts;  ///< [microseconds]

  uint8_t gps_ts_year;   ///< 0-99 (2017 -> 17)
  uint8_t gps_ts_month;  ///< 1-12
  uint8_t gps_ts_day;    ///< 1-31
  uint8_t gps_ts_hour;   ///< 0-23
  uint8_t gps_ts_min;    ///< 0-59
  uint8_t gps_ts_sec;    ///< 0-59

  uint8_t return_count;
  uint8_t segment_count;  ///< Number of image segments

#ifdef CEPTON_SIMPLE
  /// Bit flags.
  uint32_t flags;
#else
  union {
    /// Bit flags.
    uint32_t flags;
    struct {
      uint32_t is_mocked : 1;          ///< Created by capture replay
      uint32_t is_pps_connected : 1;   ///< GPS PPS is available
      uint32_t is_nmea_connected : 1;  ///< GPS NMEA is available
      uint32_t is_ptp_connected : 1;   ///< PTP is available
      uint32_t is_calibrated : 1;
      uint32_t is_over_heated : 1;  ///< Hit temperature limit (only available
                                    ///< in Vista Gen2 for now)
      uint32_t is_sync_firing_enabled : 1;
    };
  };
#endif
};
CEPTON_EXPORT extern const size_t cepton_sensor_information_size;

enum _CeptonSensorReturnType {
  CEPTON_RETURN_STRONGEST = 1 << 0,
  CEPTON_RETURN_FARTHEST = 1 << 1,
};
typedef uint8_t CeptonSensorReturnType;

/// Point in image coordinates (focal length = 1).
/**
 * To convert to 3d point, refer to `cepton_sdk_util.hpp`.
 */
struct CEPTON_EXPORT CeptonSensorImagePoint {
  int64_t timestamp;  ///< Unix time [microseconds].
  float image_x;      ///< x image coordinate.
  float distance;     ///< Distance [meters].
  float image_z;      ///< z image coordinate.
  float intensity;    ///< Diffuse reflectance.
  CeptonSensorReturnType return_type;

#ifdef CEPTON_SIMPLE
  /// Bit flags.
  uint8_t flags;
#else
  union {
    /// Bit flags.
    uint8_t flags;
    struct {
      /// If `false`, then the distance and intensity are invalid.
      uint8_t valid : 1;
      /// If `true`, then the intensity is invalid. Also, the distance is valid,
      /// but inaccurate.
      uint8_t saturated : 1;
    };
  };
#endif
  uint8_t reserved[2];
};
CEPTON_EXPORT extern const size_t cepton_sensor_image_point_size;

//------------------------------------------------------------------------------
// Limits to help application to preallocation of buffers
// (These numbers are guaranteed to be safe for 6 months from SDK release)
//------------------------------------------------------------------------------
#define CEPTON_SDK_MAX_POINTS_PER_PACKET 400
#define CEPTON_SDK_MAX_POINTS_PER_FRAME 50000
#define CEPTON_SDK_MAX_POINTS_PER_SECOND 1000000
#define CEPTON_SDK_MAX_FRAMES_PER_SECOND 40

//------------------------------------------------------------------------------
// SDK Setup
//------------------------------------------------------------------------------
typedef uint32_t CeptonSDKControl;

/// SDK control flags.
enum _CeptonSDKControl {
  /// Disable networking operations.
  /**
   * Useful for running multiple instances of sdk in different processes.
   * Must pass packets manually to `cepton_sdk::mock_network_receive`.
   */
  CEPTON_SDK_CONTROL_DISABLE_NETWORK = 1 << 1,
  /// Disable marking image clipped points as invalid.
  /**
   * Does not affect number of points returned.
   */
  CEPTON_SDK_CONTROL_DISABLE_IMAGE_CLIP = 1 << 2,
  /// Disable marking distance clipped points as invalid.
  /**
   * Does not affect number of points returned.
   */
  CEPTON_SDK_CONTROL_DISABLE_DISTANCE_CLIP = 1 << 3,
  /// Enable multiple returns.
  /**
   * When set, `cepton_sdk::SensorInformation::return_count` will indicate the
   * number of returns per laser. Can only be set at sdk initialization.
   */
  CEPTON_SDK_CONTROL_ENABLE_MULTIPLE_RETURNS = 1 << 4,
  /// Enable marking stray points as invalid (measurement noise).
  /**
   * Uses `cepton_sdk::util::StrayFilter` to mark points invalid.
   *
   * Does not affect number of points returned.
   */
  CEPTON_SDK_CONTROL_ENABLE_STRAY_FILTER = 1 << 5,
  /// Always use packet timestamps (disable GPS/PTP timestamps).
  CEPTON_SDK_CONTROL_HOST_TIMESTAMPS = 1 << 6,
  /// Enable marking crosstalk points as invalid.
  CEPTON_SDK_CONTROL_ENABLE_CROSSTALK_FILTER = 1 << 7,
};

typedef uint32_t CeptonSDKFrameMode;

/// Controls frequency of points being reported.
enum _CeptonSDKFrameMode {
  /// Report points by packet.
  CEPTON_SDK_FRAME_STREAMING = 0,
  /// Report points at fixed time intervals.
  /**
   * Interval controlled by `CeptonSDKFrameOptions::length`.
   */
  CEPTON_SDK_FRAME_TIMED = 1,
  /// Report points when the field of view is covered once.
  /**
   * - For HR80 series, detects half scan cycle (left-to-right or
   * right-to-left).
   */
  CEPTON_SDK_FRAME_COVER = 2,
  /// Report points when the scan pattern goes through a full cycle.
  /**
   * Typically 2x longer frame than COVER mode.
   * - For HR80 series, detects full scan cycle (left-to-right-to-left).
   * - For VISTA series, internally uses TIMED mode.
   */
  CEPTON_SDK_FRAME_CYCLE = 3,

  CEPTON_SDK_FRAME_MODE_MAX = 3
};

struct CEPTON_EXPORT CeptonSDKFrameOptions {
  size_t signature;  ///< Internal use only.
  /// Default: CEPTON_SDK_FRAME_STREAMING.
  CeptonSDKFrameMode mode;
  /// Frame length [seconds].
  /**
   * Default: 0.05.
   * Only used if mode=CEPTON_SDK_FRAME_TIMED.
   */
  float length;
};
/// Create default frame options.
CEPTON_EXPORT struct CeptonSDKFrameOptions cepton_sdk_create_frame_options();

/// SDK initialization options.
struct CEPTON_EXPORT CeptonSDKOptions {
  size_t signature;                ///< Internal use only.
  CeptonSDKControl control_flags;  ///< Default: 0.
  struct CeptonSDKFrameOptions frame;
  uint16_t port;  ///< Default: 8808.
};
/// Create default options.
CEPTON_EXPORT struct CeptonSDKOptions cepton_sdk_create_options();

/// Callback for receiving sdk and sensor errors.
/**
 * Currently, `error_data` is not used.
 */
typedef void (*FpCeptonSensorErrorCallback)(CeptonSensorHandle handle,
                                            CeptonSensorErrorCode error_code,
                                            const char *error_msg,
                                            const void *error_data,
                                            size_t error_data_size,
                                            void *user_data);

CEPTON_EXPORT int cepton_sdk_is_initialized();
/// Initializes settings and networking.
/**
 * Must be called before any other sdk function listed below.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_initialize(int ver, const struct CeptonSDKOptions *const options,
                      FpCeptonSensorErrorCallback cb, void *const user_data);

/// Resets everything and deallocates memory.
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_deinitialize();

CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_set_control_flags(CeptonSDKControl mask, CeptonSDKControl flags);
CEPTON_EXPORT CeptonSDKControl cepton_sdk_get_control_flags();
CEPTON_EXPORT int cepton_sdk_has_control_flag(CeptonSDKControl flag);

/// Clears sensors.
/**
 * Use when loading/unloading capture file.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_clear();

/// Sets network listen port.
/**
 * Default: 8808.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_set_port(uint16_t port);
CEPTON_EXPORT uint16_t cepton_sdk_get_port();

CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_set_frame_options(const struct CeptonSDKFrameOptions *const options);
CEPTON_EXPORT CeptonSDKFrameMode cepton_sdk_get_frame_mode();
CEPTON_EXPORT float cepton_sdk_get_frame_length();

//------------------------------------------------------------------------------
// Points
//------------------------------------------------------------------------------
/// Callback for receiving image points.
/**
 * Set the frame length to control the callback rate.
 */
typedef void (*FpCeptonSensorImageDataCallback)(
    CeptonSensorHandle handle, size_t n_points,
    const struct CeptonSensorImagePoint *c_points, void *user_data);

/// Sets image frames callback.
/**
 * Returns points at frequency specified by `cepton_sdk::FrameOptions::mode`.
 * Each frame contains all possible points (use
 * `cepton_sdk::SensorImagePoint::valid` to filter points). Points are ordered
 * by measurement, segment, and return:
 *
 * ```
 * measurement_count = n_points / (segment_count * return_count)
 * idx = ((i_measurement) * segment_count + i_segment) * return_count + i_return
 * ```
 *
 * Returns error if callback already registered.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_listen_image_frames(
    FpCeptonSensorImageDataCallback cb, void *const user_data);
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_unlisten_image_frames();

//------------------------------------------------------------------------------
// Sensors
//------------------------------------------------------------------------------
/**
 * Get number of sensors attached.
 * Use to check for new sensors. Sensors are not deleted until deinitialization.
 */
CEPTON_EXPORT size_t cepton_sdk_get_n_sensors();
/**
 * Returns error if sensor not found.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_get_sensor_handle_by_serial_number(uint64_t serial_number,
                                              CeptonSensorHandle *const handle);
/**
 * Valid indices are in range [0, n_sensors).
 * Returns error if index invalid.
 */

CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_get_sensor_information_by_index(
    size_t idx, struct CeptonSensorInformation *const info);
/**
 * Returns error if sensor not found.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_get_sensor_information(
    CeptonSensorHandle handle, struct CeptonSensorInformation *const info);

//------------------------------------------------------------------------------
// Serial
//------------------------------------------------------------------------------
/// Callback for receiving serial data (e.g. NMEA).
typedef void (*FpCeptonSerialReceiveCallback)(CeptonSensorHandle handle,
                                              const char *str, void *user_data);

/// Sets serial line callback.
/**
 * Useful for listening to NMEA data from GPS attached to sensor.
 *
 * Each callback contains 1 line of serial data (including newline characters).
 *
 * Returns error if callback already registered.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_listen_serial_lines(
    FpCeptonSerialReceiveCallback cb, void *const user_data);
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_unlisten_serial_lines();

//------------------------------------------------------------------------------
// Networking
//------------------------------------------------------------------------------
/// Callback for receiving network packets.
/**
 * \param handle Unique sensor identifier (e.g. IP address).
 * Returns error if callback already set.
 */
typedef void (*FpCeptonNetworkReceiveCallback)(CeptonSensorHandle handle,
                                               int64_t timestamp,
                                               const uint8_t *buffer,
                                               size_t buffer_size,
                                               void *user_data);

/// Sets network packets callback.
/**
 * Only 1 callback can be registered.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_listen_network_packet(
    FpCeptonNetworkReceiveCallback cb, void *const user_data);
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_unlisten_network_packet();

/// Manually passes packets to sdk.
/**
 * Blocks while processing, and calls listener callbacks synchronously before
 * returning.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_mock_network_receive(
    CeptonSensorHandle handle, int64_t timestamp, const uint8_t *const buffer,
    size_t buffer_size);

//------------------------------------------------------------------------------
// Capture Replay
//------------------------------------------------------------------------------
CEPTON_EXPORT int cepton_sdk_capture_replay_is_open();
/// Opens capture file.
/**
 * Must be called before any other replay functions listed below.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_open(const char *const path);
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_capture_replay_close();
CEPTON_EXPORT const char *cepton_sdk_capture_replay_get_filename();

/// Returns capture start timestamp (unix time [microseconds]).
CEPTON_EXPORT int64_t cepton_sdk_capture_replay_get_start_time();
/// Returns capture file position [seconds].
CEPTON_EXPORT float cepton_sdk_capture_replay_get_position();
/// Returns capture file length [seconds].
CEPTON_EXPORT float cepton_sdk_capture_replay_get_length();
/// Returns true if at end of capture file.
/**
 * This is only relevant when using `resume_blocking` methods.
 */
CEPTON_EXPORT int cepton_sdk_capture_replay_is_end();
CEPTON_DEPRECATED CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_rewind();
/// Seek to capture file position [seconds].
/**
 * Position must be in range [0.0, capture length).
 * Returns error if position is invalid.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_seek(float position);

/// If enabled, replay will automatically rewind at end.
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_set_enable_loop(int enable_loop);
CEPTON_EXPORT int cepton_sdk_capture_replay_get_enable_loop();

/// Replay speed multiplier for asynchronous replay.
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_set_speed(float speed);
CEPTON_EXPORT float cepton_sdk_capture_replay_get_speed();

/// Replay next packet in current thread without sleeping.
/**
 * Pauses replay thread if it is running.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_resume_blocking_once();
/// Replay multiple packets synchronously.
/**
 * No sleep between packets. Resume duration must be non-negative.
 * Pauses replay thread if it is running.
 */
CEPTON_EXPORT CeptonSensorErrorCode
cepton_sdk_capture_replay_resume_blocking(float duration);
/// Returns true if replay thread is running.
CEPTON_EXPORT int cepton_sdk_capture_replay_is_running();
// Resumes asynchronous replay thread.
/**
 * Packets are replayed in realtime. Replay thread sleeps in between packets.
 */
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_capture_replay_resume();
/// Pauses asynchronous replay thread.
CEPTON_EXPORT CeptonSensorErrorCode cepton_sdk_capture_replay_pause();

#include "cepton_sdk_undef.h"

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // CEPTON_SDK_H
